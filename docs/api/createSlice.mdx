---
id: createSlice
title: createSlice
sidebar_label: createSlice
hide_title: true
---

&nbsp;

# `createSlice`

A function that accepts an initial state, an object of reducer functions, and a "slice name",
and automatically generates action creators and action types that correspond to the reducers and state.

This API is the standard approach for writing Redux logic.

Internally, it uses [`createAction`](./createAction.mdx) and [`createReducer`](./createReducer.mdx), so
you may also use [Immer](../usage/immer-reducers.md) to write "mutating" immutable updates:

```ts
import { createSlice } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

interface CounterState {
  value: number
}

const initialState = { value: 0 } as CounterState

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment(state) {
      state.value++
    },
    decrement(state) {
      state.value--
    },
    incrementByAmount(state, action: PayloadAction<number>) {
      state.value += action.payload
    },
  },
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions
export default counterSlice.reducer
```

## Parameters

`createSlice` accepts a single configuration object parameter, with the following options:

```ts no-transpile
function createSlice({
    // A name, used in action types
    name: string,
    // The initial state for the reducer
    initialState: State,
    // An object of "case reducers". Key names will be used to generate actions.
    reducers: Record<string, ReducerFunction | ReducerAndPrepareObject>,
    // A "builder callback" function used to add more reducers
    extraReducers?: (builder: ActionReducerMapBuilder<State>) => void,
    // A preference for the slice reducer's location, used by `combineSlices` and `slice.selectors`. Defaults to `name`.
    reducerPath?: string,
    // An object of selectors, which receive the slice's state as their first parameter.
    selectors?: Record<string, (sliceState: State, ...args: any[]) => any>,
})
```

### `initialState`

The initial state value for this slice of state.

This may also be a "lazy initializer" function, which should return an initial state value when called. This will be used whenever the reducer is called with `undefined` as its state value, and is primarily useful for cases like reading initial state from `localStorage`.

### `name`

A string name for this slice of state. Generated action type constants will use this as a prefix.

### `reducers`

An object containing Redux "case reducer" functions (functions intended to handle a specific action type, equivalent
to a single case statement in a switch).

The keys in the object will be used to generate string action type constants, and these will show up in the Redux
DevTools Extension when they are dispatched. Also, if any other part of the application happens to dispatch an action
with the exact same type string, the corresponding reducer will be run. Therefore, you should give the functions
descriptive names.

This object will be passed to [`createReducer`](./createReducer.mdx), so the reducers may safely "mutate" the
state they are given.

```ts
import { createSlice } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
  },
})
// Will handle the action type `'counter/increment'`
```

#### Customizing Generated Action Creators

If you need to customize the creation of the payload value of an action creator by means of a [`prepare callback`](./createAction.mdx#using-prepare-callbacks-to-customize-action-contents), the value of the appropriate field of the `reducers` argument object should be an object instead of a function. This object must contain two properties: `reducer` and `prepare`. The value of the `reducer` field should be the case reducer function while the value of the `prepare` field should be the prepare callback function:

```ts
import { createSlice, nanoid } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'

interface Item {
  id: string
  text: string
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Item[],
  reducers: {
    addTodo: {
      reducer: (state, action: PayloadAction<Item>) => {
        state.push(action.payload)
      },
      prepare: (text: string) => {
        const id = nanoid()
        return { payload: { id, text } }
      },
    },
  },
})
```

### The `reducers` "creator callback" notation

Alternatively, the `reducers` field can be a callback which receives a "create" object.

The main benefit of this is that you can use [custom creators](#custom-creators) such as [async thunks](./createAsyncThunk) as part of your slice (though for bundle size reasons, you [need a bit of setup for this](#createasyncthunk)). Types are also slightly simplified for prepared reducers.

```ts title="Creator callback for reducers"
import { buildCreateSlice, asyncThunkCreator, nanoid } from '@reduxjs/toolkit'

const createSlice = buildCreateSlice({
  creators: { asyncThunk: asyncThunkCreator },
})

interface Item {
  id: string
  text: string
}

interface TodoState {
  loading: boolean
  todos: Item[]
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: {
    loading: false,
    todos: [],
  } as TodoState,
  reducers: (create) => ({
    deleteTodo: create.reducer<number>((state, action) => {
      state.todos.splice(action.payload, 1)
    }),
    addTodo: create.preparedReducer(
      (text: string) => {
        const id = nanoid()
        return { payload: { id, text } }
      },
      // action type is inferred from prepare callback
      (state, action) => {
        state.todos.push(action.payload)
      }
    ),
    fetchTodo: create.asyncThunk(
      async (id: string, thunkApi) => {
        const res = await fetch(`myApi/todos?id=${id}`)
        return (await res.json()) as Item
      },
      {
        pending: (state) => {
          state.loading = true
        },
        rejected: (state, action) => {
          state.loading = false
        },
        fulfilled: (state, action) => {
          state.loading = false
          state.todos.push(action.payload)
        },
      }
    ),
  }),
})

export const { addTodo, deleteTodo, fetchTodo } = todosSlice.actions
```

#### Create Methods

#### `create.reducer`

A standard slice case reducer.

**Parameters**

- **reducer** The slice case reducer to use.

```ts no-transpile
create.reducer<Todo>((state, action) => {
  state.todos.push(action.payload)
})
```

#### `create.preparedReducer`

A [prepared](#customizing-generated-action-creators) reducer, to customize the action creator.

**Parameters**

- **prepareAction** The [`prepare callback`](./createAction#using-prepare-callbacks-to-customize-action-contents).
- **reducer** The slice case reducer to use.

The action passed to the case reducer will be inferred from the prepare callback's return.

```ts no-transpile
create.preparedReducer(
  (text: string) => {
    const id = nanoid()
    return { payload: { id, text } }
  },
  (state, action) => {
    state.todos.push(action.payload)
  }
)
```

#### `create.asyncThunk`

Creates an async thunk instead of an action creator.

:::warning Setup

To avoid pulling `createAsyncThunk` into the bundle size of `createSlice` by default, some extra setup is required to use `create.asyncThunk`.

The version of `createSlice` exported from RTK will not include an `asyncThunk` property on the `create` object.

Instead, import `buildCreateSlice` and `asyncThunkCreator`, and create your own version of `createSlice`:

```ts
import { buildCreateSlice, asyncThunkCreator } from '@reduxjs/toolkit'

export const createAppSlice = buildCreateSlice({
  creators: { asyncThunk: asyncThunkCreator },
})
```

Then import this `createAppSlice` as needed instead of the exported version from RTK.

:::

**Parameters**

- **payloadCreator** The thunk [payload creator](./createAsyncThunk#payloadcreator).
- **config** The configuration object. (optional)

The configuration object can contain case reducers for each of the [lifecycle actions](./createAsyncThunk#promise-lifecycle-actions) (`pending`, `fulfilled`, and `rejected`), as well as a `settled` reducer that will run for both fulfilled and rejected actions (note that this will run _after_ any provided `fulfilled`/`rejected` reducers. Conceptually it can be thought of like a `finally` block.).

Each case reducer will be attached to the slice's `caseReducers` object, e.g. `slice.caseReducers.fetchTodo.fulfilled`.

The configuration object can also contain [`options`](./createAsyncThunk#options).

```ts no-transpile
create.asyncThunk(
  async (id: string, thunkApi) => {
    const res = await fetch(`myApi/todos?id=${id}`)
    return (await res.json()) as Item
  },
  {
    pending: (state) => {
      state.loading = true
    },
    rejected: (state, action) => {
      state.error = action.payload ?? action.error
    },
    fulfilled: (state, action) => {
      state.todos.push(action.payload)
    },
    settled: (state, action) => {
      state.loading = false
    }
    options: {
      idGenerator: uuid,
    },
  }
)
```

:::note

Typing for the `create.asyncThunk` works in the same way as [`createAsyncThunk`](../usage/usage-with-typescript#createasyncthunk), with one key difference.

A type for `state` and/or `dispatch` _cannot_ be provided as part of the `ThunkApiConfig`, as this would cause circular types.

Instead, it is necessary to assert the type when needed - `getState() as RootState`. You may also include an explicit return type for the payload function as well, in order to break the circular type inference cycle.

```ts no-transpile
create.asyncThunk<Todo, string, { rejectValue: { error: string } }>(
  // highlight-start
  // may need to include an explicit return type
  async (id: string, thunkApi): Promise<Todo> => {
    // Cast types for `getState` and `dispatch` manually
    const state = thunkApi.getState() as RootState
    const dispatch = thunkApi.dispatch as AppDispatch
    // highlight-end
    try {
      const todo = await fetchTodo()
      return todo
    } catch (e) {
      throw thunkApi.rejectWithValue({
        error: 'Oh no!',
      })
    }
  }
)
```

For common thunk API configuration options, a [`withTypes` helper](../usage/usage-with-typescript#defining-a-pre-typed-createasyncthunk) is provided:

```ts no-transpile
reducers: (create) => {
  const createAThunk =
    create.asyncThunk.withTypes<{ rejectValue: { error: string } }>()

  return {
    fetchTodo: createAThunk<Todo, string>(async (id, thunkApi) => {
      throw thunkApi.rejectWithValue({
        error: 'Oh no!',
      })
    }),
    fetchTodos: createAThunk<Todo[], string>(async (id, thunkApi) => {
      throw thunkApi.rejectWithValue({
        error: 'Oh no, not again!',
      })
    }),
  }
}
```

:::

### `extraReducers`

Conceptually, each slice reducer "owns" its slice of state. There's also a natural correspondance between the update logic defined inside `reducers`, and the action types that are generated based on those.

However, there are many times that a Redux slice may also need to update its own state in response to action types that were defined elsewhere in the application (such as clearing many different kinds of data when a "user logged out" action is dispatched). This can include action types defined by another `createSlice` call, actions generated by a `createAsyncThunk`, RTK Query endpoint matchers, or any other action. In addition, one of the key concepts of Redux is that many slice reducers can independently respond to the same action type.

**`extraReducers` allows `createSlice` to respond and update its own state in response to other action types besides the types it has generated.**

As with the `reducers` field, each case reducer in `extraReducers` is [wrapped in Immer and may use "mutating" syntax to safely update the state inside](../usage/immer-reducers.md).

However, unlike the `reducers` field, each individual case reducer inside of `extraReducers` will _not_ generate a new action type or action creator.

If two fields from `reducers` and `extraReducers` happen to end up with the same action type string, the function from `reducers` will be used to handle that action type.

#### The `extraReducers` "builder callback" notation

Similar to `createReducer`, the `extraReducers` field uses a "builder callback" notation to define handlers for specific action types, matching against a range of actions, or handling a default case. This is conceptually similar to a switch statement, but with better TS support as it can infer the action type from the provided action creator. It's particularly useful for working with actions produced by `createAction` and `createAsyncThunk`.

[examples](docblock://createSlice.ts?token=CreateSliceOptions.extraReducers)

See [the "Builder Callback Notation" section of the `createReducer` reference](./createReducer.mdx#usage-with-the-builder-callback-notation) for details on how to use `builder.addCase`, `builder.addMatcher`, and `builder.addDefault`

### `reducerPath`

Indicates a preference of where the slice should be located. Defaults to [`name`](#name).

This is used by `combineSlices` and the default generated `slice.selectors`.

### `selectors`

A set of selectors that receive the slice state as their first parameter, and any other parameters.

Each selector will have a corresponding key in the resulting [`selectors`](#selectors-1) object.

:::caution Circular types

It's fairly common to have selectors that use other selectors. This is still possible with slice selectors, but defining a selector without a return type can cause a circular type inference problem:

```ts no-transpile
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {},
  selectors: {
    selectValue: (state) => state.value,
    // highlight-start
    // this creates a cycle, because it's inferring a type from the object we're creating here
    selectTimes: (state, times = 1) =>
      counterSlice.getSelectors().selectValue(state) * times,
    // highlight-end
  },
})
```

This cycle can be fixed by providing an explicit return type for the selector:

```ts no-transpile
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {},
  selectors: {
    selectValue: (state) => state.value,
    // highlight-start
    // explicit return type means cycle is broken
    selectTimes: (state, times = 1): number =>
      counterSlice.getSelectors().selectValue(state) * times,
    // highlight-end
  },
})
```

This limitation may be also encountered when using a slice's `asyncThunk` creator.
In the same way, the issue is resolved by explicitly providing a type somewhere in the chain and breaking the cycle.

```ts no-transpile
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: (create) => ({
    getCountData: create.asyncThunk(async (_arg, { getState }) => {
      const currentCount = counterSlice.selectors.selectValue(
        getState() as RootState
      )
      // highlight-start
      // this would cause a circular type, but the type annotation breaks the circle
      const result: Response = await fetch('api/' + currentCount)
      // highlight-end
      return result.json()
    }),
  }),
  selectors: {
    selectValue: (state) => state.value,
  },
})
```

:::

## Return Value

`createSlice` will return an object that looks like:

```ts no-transpile
{
    name: string,
    reducer: ReducerFunction,
    actions: Record<string, ActionCreator>,
    caseReducers: Record<string, CaseReducer>.
    getInitialState: () => State,
    reducerPath: string,
    selectSlice: Selector;
    selectors: Record<string, Selector>,
    getSelectors: (selectState: (rootState: RootState) => State) => Record<string, Selector>
    injectInto: (injectable: Injectable, config?: InjectConfig & { reducerPath?: string }) => InjectedSlice
}
```

Each function defined in the `reducers` argument will have a corresponding action creator generated using [`createAction`](./createAction.mdx)
and included in the result's `actions` field using the same function name.

The generated `reducer` function is suitable for passing to the Redux `combineReducers` function as a "slice reducer".

You may want to consider destructuring the action creators and exporting them individually, for ease of searching
for references in a larger codebase.

The functions passed to the `reducers` parameter can be accessed through the `caseReducers` return field. This can be particularly useful for testing or direct access to reducers created inline.

Result's function `getInitialState` provides access to the initial state value given to the slice. If a lazy state initializer was provided, it will be called and a fresh value returned.

`injectInto` creates an instance of the slice that is aware it's been injected - see [`combineSlices`](./combineSlices#slice-integration).

:::note
The result object is conceptually similar to a
["Redux duck" code structure](https://redux.js.org/faq/code-structure#what-should-my-file-structure-look-like-how-should-i-group-my-action-creators-and-reducers-in-my-project-where-should-my-selectors-go).
The actual code structure you use is up to you, but it's worth keeping in mind that actions are not exclusively limited to a single slice.
Any part of the reducer logic can (and should!) respond to any dispatched action.
:::

### Selectors

Slice selectors are written to expect the slice's state as their first parameter, but the slice may be located anywhere inside the store's root state.

As a result, there are two ways of getting final selectors:

#### `selectors`

Most commonly, the slice is reliably mounted under its [`reducerPath`](#reducerPath).

Following this, the slice has a `selectSlice` selector attached, which assumes that the slice is located under `rootState[slice.reducerPath]`.

`slice.selectors` then uses this selector to wrap each of the selectors provided.

```ts
import { createSlice } from '@reduxjs/toolkit'

interface CounterState {
  value: number
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    // omitted
  },
  selectors: {
    selectValue: (sliceState) => sliceState.value,
  },
})

console.log(counterSlice.selectSlice({ counter: { value: 2 } })) // { value: 2 }

const { selectValue } = counterSlice.selectors

console.log(selectValue({ counter: { value: 2 } })) // 2
```

:::note

The original selector passed is attached to the wrapped selector as `.unwrapped`. For example:

```ts
import { createSlice, createSelector } from '@reduxjs/toolkit'

interface CounterState {
  value: number
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    // omitted
  },
  selectors: {
    selectDouble: createSelector(
      (sliceState: CounterState) => sliceState.value,
      (value) => value * 2
    ),
  },
})

const { selectDouble } = counterSlice.selectors

console.log(selectDouble({ counter: { value: 2 } })) // 4
console.log(selectDouble({ counter: { value: 3 } })) // 6
console.log(selectDouble.unwrapped.recomputations) // 2
```

:::

#### `getSelectors`

`slice.getSelectors` is called with a single parameter, a `selectState` callback. This function should receive the store root state (or whatever you expect to call the resulting selectors with) and return the slice state.

```ts no-transpile
const { selectValue } = counterSlice.getSelectors(
  (rootState: RootState) => rootState.aCounter
)

console.log(selectValue({ aCounter: { value: 2 } })) // 2
```

If no `selectState` callback is passed, selectors will be returned as is - expecting the slice state as their first parameter (the same as calling `slice.getSelectors(state => state)`).

```ts no-transpile
const { selectValue } = counterSlice.getSelectors()

console.log(selectValue({ value: 2 })) // 2
```

:::note
The [`slice.selectors`](#selectors-2) object is the equivalent of calling

```ts no-transpile
const { selectValue } = counterSlice.getSelectors(counterSlice.selectSlice)
// or
const { selectValue } = counterSlice.getSelectors(
  (state: RootState) => state[counterSlice.reducerPath]
)
```

:::

## Examples

```ts
import { createSlice, createAction, configureStore } from '@reduxjs/toolkit'
import type { PayloadAction } from '@reduxjs/toolkit'
import { combineReducers } from 'redux'

const incrementBy = createAction<number>('incrementBy')
const decrementBy = createAction<number>('decrementBy')

const counter = createSlice({
  name: 'counter',
  initialState: 0 as number,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
    multiply: {
      reducer: (state, action: PayloadAction<number>) => state * action.payload,
      prepare: (value?: number) => ({ payload: value || 2 }), // fallback if the payload is a falsy value
    },
  },
  extraReducers: (builder) => {
    builder.addCase(incrementBy, (state, action) => {
      return state + action.payload
    })
    builder.addCase(decrementBy, (state, action) => {
      return state - action.payload
    })
  },
})

const user = createSlice({
  name: 'user',
  initialState: { name: '', age: 20 },
  reducers: {
    setUserName: (state, action) => {
      state.name = action.payload // mutate the state all you want with immer
    },
  },
  extraReducers: (builder) => {
    builder.addCase(counter.actions.increment, (state, action) => {
      state.age += 1
    })
  },
})

const store = configureStore({
  reducer: {
    counter: counter.reducer,
    user: user.reducer,
  },
})

store.dispatch(counter.actions.increment())
// -> { counter: 1, user: {name : '', age: 21} }
store.dispatch(counter.actions.increment())
// -> { counter: 2, user: {name: '', age: 22} }
store.dispatch(counter.actions.multiply(3))
// -> { counter: 6, user: {name: '', age: 22} }
store.dispatch(counter.actions.multiply())
// -> { counter: 12, user: {name: '', age: 22} }
console.log(counter.actions.decrement.type)
// -> "counter/decrement"
store.dispatch(user.actions.setUserName('eric'))
// -> { counter: 12, user: { name: 'eric', age: 22} }
```

## Custom creators

TODO: a blurb introducing the idea of custom creators

### Reducer definitions

A reducer definition is an object (or function) with a `_reducerDefinitionType` property indicating which creator should handle it. Other than this property, it is entirely up to you what this definition object can look like.

For example, the `create.preparedReducer` creator uses a definition that looks like `{ prepare, reducer }`.

The callback form of `reducers` should return an object of reducer definitions, by calling creators and nesting the result of each under a key.

```js no-transpile
reducers: (create) => ({
  addTodo: create.preparedReducer(
    (todo) => ({ payload: { id: nanoid(), ...todo } }),
    (state, action) => {
      state.push(action.payload)
    }
  ),
})
// becomes
const definitions = {
  addTodo: {
    _reducerDefinitionType: 'reducerWithPrepare',
    prepare: (todo) => ({ payload: { id: nanoid(), ...todo } }),
    reducer: (state, action) => {
      state.push(action.payload)
    },
  },
}
```

Typically a creator will return a [single reducer definition](#single-definitions), but it could return an object of [multiple definitions](#multiple-definitions) to be spread into the final object, or [something else entirely](#other)!

### Creator definitions

A creator definition is an object with a `type` property, a `create` method, and an optional `handle` method.

The `type` property should be the same constant used for reducer definitions to be handled by this creator. To avoid collision, we recommend using Symbols for this. It's also used for defining/retrieving types - see [Typescript](#typescript).

```ts no-transpile
const reducerCreatorType = Symbol()

const reducerCreator: ReducerCreator<typeof reducerCreatorType> = {
  type: reducerCreatorType,
  create(reducer) {
    return {
      _reducerDefinitionType: reducerCreatorType,
      reducer,
    }
  },
  handle({ reducerName, type }, definition, context) {
    const { reducer } = definition
    const actionCreator = createAction(type)
    context
      .addCase(actionCreator, reducer)
      .exposeAction(reducerName, actionCreator)
      .exposeCaseReducer(reducerName, reducer)
  },
}
```

#### `create`

The `create` method is the function that will be attached to the `create` object, before it's passed to the `reducers` callback.

Because it's a function, the `this` value will be the final `create` object when called (assuming a `create.creator()` call). It also could have additional methods attached.

The actual name the creator will be nested under is taken from the `buildCreateSlice` call. For example, `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` results in the creator being available as `create.asyncThunk`.

See the [Further examples](#further-examples) section for some examples of these.

#### `handle`

The `handle` callback of a creator will be called for any reducer definitions with a matching `_reducerDefinitionType` property.

:::note
A creator only needs a `handle` callback if it expects to be called with reducer definitions. If it only calls other creators (see [Using `this` to access other creators](#create-1)), it can omit the `handle`.
:::

It receives three arguments: details about the reducer, the definition, and a `context` object with methods to modify the slice.

The reducer details object has two properties:

- `reducerName` - the key the reducer definition was under (e.g. `addTodo`)
- `type` - the automatically generated type string for the reducer (e.g. `todos/addTodo`)

The context object includes:

#### `addCase`

The same as [`addCase`](./createReducer#builderaddcase) for `createReducer` and `extraReducers`. Adds a case reducer for a given action type, and can receive an action type string or an action creator with a `.type` property.

```ts no-transpile
const action = createAction(type)
context.addCase(action, reducer)
```

#### `addMatcher`

The same as [`addMatcher`](./createReducer#builderaddmatcher) for `createReducer` and `extraReducers`. Adds a case reducer which will be called when a given matcher returns true.

```ts no-transpile
const matcher = isAnyOf(action, action2)
context.addMatcher(matcher, reducer)
```

#### `exposeAction`

Attaches a value to `slice.actions`. Receives the key to be set under (typically `reducerName`) and the value to be set.

```ts no-transpile
const action = createAction(type)
context.exposeAction(reducerName, action)
```

#### `exposeCaseReducer`

Attaches a value to `slice.caseReducers`. Receives the key to be set under (typically `reducerName`) and the value to be set.

```ts no-transpile
context.exposeCaseReducer(reducerName, reducer)
```

#### `getInitialState`

Returns the initial state value for the slice. If a lazy state initializer has been provided, it will be called and a fresh value returned.

```ts no-transpile
const resetAction = createAction(type)
const resetReducer = () => context.getInitialState()
context
  .addCase(resetAction, resetReducer)
  .exposeAction(reducerName, resetAction)
  .exposeCaseReducer(reducerName, resetReducer)
```

### Typescript

The Typescript system for custom slice creators uses a "creator registry" system similar to the module system for [RTK Query](/rtk-query/usage/customizing-create-api#creating-your-own-module).

Creators are registered by using module augmentation to add a new key (their unique `type`) to the `SliceReducerCreators` interface. The interface receives three type parameters (`State`, `CaseReducers` and `Name`), and each entry should use the `ReducerCreatorEntry` type utility.

```ts no-transpile
const reducerCreatorType = Symbol()

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [reducerCreatorType]: ReducerCreatorEntry<
      () => ReducerDefinition<typeof reducerCreatorType>
    >
  }
}
```

The `ReducerCreatorEntry<Create, Exposes>` utility has two type parameters:

#### `Create`

The signature of the `create` method of the creator definition.

:::tip Using `this` to access other creators

Assuming the creator is called as `create.yourCreator()`, the `this` value for the function is the `create` object - meaning you can call other creators on the same object.

However, this should be specifically included in the function signature, so Typescript can warn if called with an incorrect context (for example, if the user destructures from the `create` value).

```ts no-transpile
const batchedCreatorType = Symbol()

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [batchedCreatorType]: ReducerCreatorEntry<
      <Payload>(
        // highlight-next-line
        this: ReducerCreators<State, {}>,
        reducer: CaseReducer<State, PayloadAction<Payload>>
      ) => PreparedCaseReducerDefinition<
        State,
        (payload: Payload) => { payload: Payload; meta: unknown }
      >
    >
  }
}

const batchedCreator: ReducerCreator<typeof batchedCreatorType> = {
  type: batchedCreatorType,
  create(reducer) {
    return this.preparedReducer(prepareAutoBatched(), reducer)
  },
}
```

The second argument to the `ReducerCreators` type is a map from creator names to types, which you should supply if you're expecting to use any custom creators (anything other than `reducer` and `preparedReducer`) within your own creator. For example, `ReducerCreators<State, { asyncThunk: typeof asyncThunkCreator.type }>` would allow you to call `this.asyncThunk`.

:::

#### `Exposes`

The second type parameter for `ReducerCreatorEntry` is optional, but should be used if the creator will handle some reducer definitions itself. It indicates what actions and case reducers will be attached to the slice, and is used to determine the final types of `slice.actions` and `slice.caseReducers`.

It should be an object with some of the following properties:

##### `actions`

The actions property will typically be a [mapped type](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) over the `CaseReducers` type parameter, returning what the creator's `handle` would expose when given that definition.

The `ReducerNamesOfType` utility is exported to easily filter down to reducers that would be passed to the `handle` callback.

For example, with (a simplified version of) the `asyncThunk` creator:

```ts no-transpile
const asyncThunkCreatorType = Symbol()

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [asyncThunkCreatorType]: ReducerCreatorEntry<
      <ThunkArg, Returned>(
        payloadCreator: AsyncThunkPayloadCreator<ThunkArg, Returned>
      ) => AsyncThunkReducerDefinition<State, ThunkArg, Returned>,
      {
        // highlight-start
        actions: {
          [ReducerName in ReducerNamesOfType<
            CaseReducers,
            typeof asyncThunkCreatorType
          >]: CaseReducers[ReducerName] extends AsyncThunkReducerDefinition<
            State,
            infer ThunkArg,
            infer Returned
          >
            ? AsyncThunk<ThunkArg, Returned>
            : never
        }
        // highlight-end
      }
    >
  }
}
```

##### `caseReducers`

Similar to `actions`, except for `slice.caseReducers`.

For example, with the `preparedReducer` creator:

```ts no-transpile
const preparedReducerType = Symbol()

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [preparedReducerType]: ReducerCreatorEntry<
      <Prepare extends PrepareAction<any>>(
        prepare: Prepare,
        caseReducer: CaseReducer<State, ActionForPrepare<Prepare>>
      ) => PreparedCaseReducerDefinition<State, Prepare>,
      {
        actions: {
          [ReducerName in ReducerNamesOfType<
            CaseReducers,
            typeof preparedReducerType
          >]: CaseReducers[ReducerName] extends { prepare: any }
            ? ActionCreatorForCaseReducerWithPrepare<
                CaseReducers[ReducerName],
                SliceActionType<Name, ReducerName>
              >
            : never
        }
        // highlight-start
        caseReducers: {
          [ReducerName in ReducerNamesOfType<
            CaseReducers,
            typeof preparedReducerType
          >]: CaseReducers[ReducerName] extends { reducer: infer Reducer }
            ? Reducer
            : never
        }
        // highlight-end
      }
    >
  }
}
```

### Further examples

TODO: blurb

#### Single definitions

Commonly, a creator will return a single reducer definition, to be handled by either itself or another creator.

One example would be reusable toast logic; you could have a reducer creator that makes a thunk creator. That thunk would dispatch an "show" action immediately when called, and then dispatch a second "hide" action after a given amount of time.

```ts no-transpile
// create the unique type
const toastCreatorType = Symbol()

interface Toast {
  message: string
}

interface ToastReducerConfig<State> {
  shown?: CaseReducer<State, PayloadAction<Toast, string, { id: string }>>
  hidden?: CaseReducer<State, PayloadAction<undefined, string, { id: string }>>
}

interface ToastThunkCreator<
  SliceName extends string,
  ReducerName extends string
> {
  (toast: Toast, timeout?: number): ThunkAction<
    { hide(): void },
    unknown,
    unknown,
    UnknownAction
  >
  shown: PayloadActionCreator<
    Toast,
    `${SliceActionType<SliceName, ReducerName>}/shown`,
    (toast: Toast, id: string) => { payload: Toast; meta: { id: string } }
  >
  hidden: PayloadActionCreator<
    void,
    `${SliceActionType<SliceName, ReducerName>}/hidden`,
    (id: string) => { payload: undefined; meta: { id: string } }
  >
}

// register the creator types
declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [toastCreatorType]: ReducerCreatorEntry<
      (
        config: ToastReducerConfig<State>
      ) => ToastReducerConfig<State> &
        ReducerDefinition<typeof toastCreatorType>,
      {
        actions: {
          [ReducerName in ReducerNamesOfType<
            typeof toastCreatorType
          >]: ToastThunkCreator<Name, ReducerName>
        }
        caseReducers: {
          [ReducerName in ReducerNamesOfType<
            typeof toastCreatorType
          >]: Required<ToastReducerConfig<State>>
        }
      }
    >
  }
}

// define the creator
const toastCreator: ReducerCreator<typeof toastCreatorType> = {
  type: toastCreatorType,
  // return the reducer definition
  create(config) {
    return {
      _reducerDefinitionType: toastCreatorType,
      ...config,
    }
  },
  // handle the reducer definition
  handle({ reducerName, type }, definition, context) {
    // make the action creators
    const shown = createAction(type + '/shown', (toast: Toast, id: string) => ({
      payload: toast,
      meta: { id },
    }))
    const hidden = createAction(type + '/hidden', (id: string) => ({
      payload: undefined,
      meta: { id },
    }))
    // make the thunk creator
    function thunkCreator(
      toast: Toast,
      timeout = 300
    ): ThunkAction<{ hide(): void }, unknown, unknown, UnknownAction> {
      return (dispatch, getState) => {
        const id = nanoid()
        dispatch(shown(toast, id))
        const timeoutId = setTimeout(() => dispatch(hidden(id)), timeout)
        return {
          hide() {
            clearTimeout(timeoutId)
            dispatch(hidden(id))
          },
        }
      }
    }
    // attach the action creators to the thunk creator
    Object.assign(thunkCreator, { shown, hidden })

    // add any case reducers passed in the config
    if (definition.shown) {
      context.addCase(shown, definition.shown)
    }
    if (definition.hidden) {
      context.addCase(hidden, definition.hidden)
    }

    // expose the thunk creator as `slice.actions[reducerName]` and the case reducers as `slice.caseReducers[reducerName]["shown" | "hidden"]`
    context
      .exposeAction(reducerName, thunkCreator)
      .exposeCaseReducer(reducerName, {
        shown: definition.shown || noop,
        hidden: definition.hidden || noop,
      })
  },
}

function noop() {}

// build the `createSlice` function
const createToastSlice = buildCreateSlice({
  creators: { toaster: toastCreator },
})

const toastSlice = createToastSlice({
  name: 'toast',
  initialState: {} as Record<string, Toast>,
  reducers: (create) => ({
    // call creator to get definition, and save it to a key
    showToast: create.toaster({
      shown(state, action) {
        state[action.meta.id] = action.payload
      },
      hidden(state, action) {
        delete state[action.meta.id]
      },
    }),
  }),
})

// showToast is the thunk creator from above
const { showToast } = toastSlice.actions

// case reducers and action creators are available where we put them
toastSlice.caseReducers.showToast.hidden({}, showToast.hidden('id'))
```

#### Multiple definitions

A creator could also return multiple definitions, which would then be spread into the final definitions object. This is a more composable alternative to the [wrapping `createSlice`](usage/usage-with-typescript#wrapping-createslice) approach, as you could call multiple creators as needed.

One example could be returning some pagination related reducers.

```ts no-transpile
const paginationCreatorType = Symbol()

interface PaginationState {
  page: number
}

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [paginationCreatorType]: ReducerCreatorEntry<
      // make sure the creator is only called when state is compatible
      State extends PaginationState
        ? (this: ReducerCreators<State>) => {
            prevPage: CaseReducerDefinition<State, PayloadAction>
            nextPage: CaseReducerDefinition<State, PayloadAction>
            goToPage: CaseReducerDefinition<State, PayloadAction<number>>
          }
        : never
    >
  }
}

const paginationCreator: ReducerCreator<typeof paginationCreatorType> = {
  type: paginationCreatorType,
  create() {
    return {
      prevPage: this.reducer((state: PaginationState) => {
        state.page--
      }),
      nextPage: this.reducer((state: PaginationState) => {
        state.page++
      }),
      goToPage: this.reducer<number>((state: PaginationState, action) => {
        state.page = action.payload
      }),
    }
  },
}

const createPaginationSlice = buildCreateSlice({
  creators: { paginationReducers: paginationCreator },
})

const paginationSlice = createPaginationSlice({
  name: 'pagination',
  initialState: { page: 0, loading: false },
  reducers: (create) => ({
    ...create.paginationReducers(),
    toggleLoading: create.reducer((state) => {
      state.loading = !state.loading
    }),
  }),
})

const { prevPage, nextPage, goToPage, toggleLoading } = paginationSlice.actions
```

A creator could return a mix of reducer definitions for itself and other creators to handle:

```ts no-transpile
const historyCreatorType = Symbol()

interface PatchesState {
  undo: Patch[]
  redo: Patch[]
}

interface HistoryState<T> {
  past: PatchesState[]
  present: T
  future: PatchesState[]
}

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [paginationCreatorType]: ReducerCreatorEntry<
      // make sure the creator is only called when state is compatibleState extends HistoryState<unknown>
        ?
      (this: ReducerCreators<State>) => {
            undo: CaseReducerDefinition<State, PayloadAction>
            redo: CaseReducerDefinition<State, PayloadAction>
            reset: ReducerDefinition<typeof paginationCreatorType> & {
              type: 'reset'
            }
          }
        : never, {
      actions: {
        [ReducerName in ReducerNamesOfType<
          CaseReducers,
          typeof historyMethodsCreatorType
        >]: CaseReducers[ReducerName] extends { type: 'reset' }
          ? PayloadActionCreator<void, SliceActionType<Name, ReducerName>>
          : never
      }
      caseReducers: {
        [ReducerName in ReducerNamesOfType<
          CaseReducers,
          typeof historyMethodsCreatorType
        >]: CaseReducers[ReducerName] extends { type: 'reset' }
          ? CaseReducer<State, PayloadAction>
          : never
      }
    }>
  }
}

const historyCreator: ReducerCreator<typeof historyCreatorType> = {
  type: historyCreatorType,
  create() {
    return {
      undo: this.reducer((state: HistoryState<unknown>) => {
        const historyEntry = state.past.pop()
        if (historyEntry) {
          applyPatches(state, historyEntry.undo)
          state.future.unshift(historyEntry)
        }
      }),
      redo: this.reducer((state: HistoryState<unknown>) => {
        const historyEntry = state.future.shift()
        if (historyEntry) {
          applyPatches(state, historyEntry.redo)
          state.past.push(historyEntry)
        }
      }),
      reset: {
        _reducerDefinitionType: historyCreatorType,
        type: 'reset',
      },
    }
  },
  handle(details, definition, context) {
    if (definition.type !== 'reset') {
      throw new Error('Unrecognised definition type: ' + definition.type)
    }
    // use the normal reducer creator to create a case reducer and action creator
    const resetReducer = () => context.getInitialState()
    reducerCreator.handle(details, reducerCreator.create(resetReducer), context)
  },
}

const createHistorySlice = buildCreateSlice({
  creators: { historyMethods: historyCreator },
})

function getInitialHistoryState<T>(initialState: T): HistoryState<T> {
  return {
    past: [],
    present: initialState,
    future: [],
  }
}

const postSliceWithHistory = createHistorySlice({
  name: 'post',
  initialState: getInitialHistoryState({ title: '' }),
  reducers: (create) => ({
    ...create.historyMethods(),
  }),
})

const { undo, redo, reset } = postSliceWithHistory.actions
```

#### Other

A creator doesn't have to return any reducer definitions, it could be any sort of utility for defining reducers.

Following on from the `HistoryState` example above, it would be useful to make some sort of `undoable` utility to wrap reducers in logic which automatically updates the history of the slice.

Fortunately, this is possible with a creator:

```ts no-transpile
const undoableCreatorType = Symbol()

interface UndoableMeta {
  undoable?: boolean
}

declare module '@reduxjs/toolkit' {
  export interface SliceReducerCreators<
    State = any,
    CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>,
    Name extends string = string
  > {
    [undoableCreatorType]: ReducerCreatorEntry<
      State extends HistoryState<infer Data>
        ? {
            <A extends Action & { meta?: UndoableMeta }>(
              reducer: CaseReducer<Data, A>
            ): CaseReducer<State, A>
            withoutPayload(options?: UndoableMeta): {
              payload: undefined
              meta: UndoableMeta | undefined
            }
            withPayload<Payload>(
              payload: Payload,
              options?: UndoableMeta
            ): { payload: Payload; meta: UndoableMeta | undefined }
          }
        : never
    >
  }
}

const undoableCreator: ReducerCreator<typeof undoableCreatorType> = {
  type: undoableCreatorType,
  create: Object.assign(
    function makeUndoable<A extends Action & { meta?: UndoableOptions }>(
      reducer: CaseReducer<any, A>
    ): CaseReducer<HistoryState<any>, A> {
      return (state, action) => {
        const [nextState, redoPatch, undoPatch] = produceWithPatches(
          state,
          (draft) => {
            const result = reducer(draft.present, action)
            if (typeof result !== 'undefined') {
              draft.present = result
            }
          }
        )
        let finalState = nextState
        const undoable = action.meta?.undoable ?? true
        if (undoable) {
          finalState = createNextState(finalState, (draft) => {
            draft.past.push({
              undo: undoPatch,
              redo: redoPatch,
            })
            draft.future = []
          })
        }
        return finalState
      }
    },
    {
      withoutPayload() {
        return (options?: UndoableOptions) => ({
          payload: undefined,
          meta: options,
        })
      },
      withPayload<P>() {
        return (
          ...[payload, options]: IfMaybeUndefined<
            P,
            [payload?: P, options?: UndoableOptions],
            [payload: P, options?: UndoableOptions]
          >
        ) => ({ payload: payload as P, meta: options })
      },
    }
  ),
}

const createHistorySlice = buildCreateSlice({
  creators: { historyMethods: historyCreator, undoable: undoableCreator },
})

const postSliceWithHistory = createHistorySlice({
  name: 'post',
  initialState: getInitialHistoryState({ title: '', pinned: false }),
  reducers: (create) => ({
    ...create.historyMethods(),
    updateTitle: create.preparedReducer(
      create.undoable.withPayload<string>(),
      create.undoable((state, action) => {
        state.title = action.payload
      })
    ),
    togglePinned: create.preparedReducer(
      create.undoable.withoutPayload(),
      create.undoable((state, action) => {
        state.pinned = !state.pinned
      })
    ),
  }),
})

const { undo, redo, reset, updateTitle, togglePinned } =
  postSliceWithHistory.actions
```
